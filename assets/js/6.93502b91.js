(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{398:function(i,v,t){i.exports=t.p+"assets/img/standard.08550e23.png"},399:function(i,v,t){i.exports=t.p+"assets/img/weird.cad60530.png"},410:function(i,v,t){"use strict";t.r(v);var _=t(56),e=Object(_.a)({},(function(){var i=this,v=i.$createElement,_=i._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":i.$parent.slotKey}},[_("h1",{attrs:{id:"css那些事"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#css那些事"}},[i._v("#")]),i._v(" CSS那些事")]),i._v(" "),_("h2",{attrs:{id:"盒子模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#盒子模型"}},[i._v("#")]),i._v(" 盒子模型")]),i._v(" "),_("p",[i._v("一个正常的CSS盒子 = 显示内容(content) + 内边距(padding) + 边框(border) + 外边距(maigin)")]),i._v(" "),_("ul",[_("li",[_("p",[i._v("块级盒子（Block box）")]),i._v(" "),_("ol",[_("li",[i._v("盒子会在内联的方向拓展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着"),_("code",[i._v("盒子会和父容器一样宽")]),i._v("。")]),i._v(" "),_("li",[i._v("每一个盒子都会换行")]),i._v(" "),_("li",[_("code",[i._v("width")]),i._v("和"),_("code",[i._v("height")]),i._v("属性会发生作用")]),i._v(" "),_("li",[i._v("内边距，外边距和边框都会将其他元素从当前盒子周围推开")]),i._v(" "),_("li",[i._v("一般div，h1，p标签默认情况下都是块级盒子")])])]),i._v(" "),_("li",[_("p",[i._v("内联盒子（Inline box）")]),i._v(" "),_("ol",[_("li",[i._v("盒子不会产生换行")]),i._v(" "),_("li",[_("code",[i._v("width")]),i._v("和"),_("code",[i._v("height")]),i._v("属性不会发生作用")]),i._v(" "),_("li",[i._v("垂直方向的内边距，外边距以及边框会被应用但是不会把其他处于inline状态的盒子推开")]),i._v(" "),_("li",[i._v("水平方向的内边距，外边距以及边框会被应用且会把其他处于inline状态的盒子推开")]),i._v(" "),_("li",[i._v("一般a，span，em，strong等标签默认都是内联盒子")])])])]),i._v(" "),_("p",[i._v("一般我们通过对标签的display属性的设置，display: block比如或者display: inline，来控制盒子的"),_("code",[i._v("外部显示类型")]),i._v("。")]),i._v(" "),_("blockquote",[_("p",[i._v("css的box模型有一个外部显示类型，来决定盒子是块级还是内联。\n同样盒模型还有内部显示类型，它决定了盒子内部元素是如何布局的。默认情况下是按照 正常文档流 布局，也意味着它们和其他块元素以及内联元素一样(如上所述)\n我们可以通过使用类似 display: flex 来更改元素内部显示类型。 如果设置 display: flex，在一个元素上，外部显示类型是 block，但是内部显示类型修改为 flex。该盒子的所有直接子元素都会成为flex元素，会根据 弹性盒子（Flexbox ）规则进行布局。")])]),i._v(" "),_("p",[i._v("对一个特定元素而言，内联和块之间提供了一个中间状态那就是"),_("code",[i._v("display: inline-block")]),i._v("，实现我们需要块级元素和内联元素的部分效果：")]),i._v(" "),_("ul",[_("li",[i._v("设置"),_("code",[i._v("width")]),i._v("和"),_("code",[i._v("height")]),i._v("属性会生效")]),i._v(" "),_("li",[i._v("padding, margin, 以及border 会推开其他元素")]),i._v(" "),_("li",[i._v("不会产生换行")]),i._v(" "),_("li",[i._v("显式添加width 和height 属性，它只会变得比其内容更大")])]),i._v(" "),_("h2",{attrs:{id:"box-sizing"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#box-sizing"}},[i._v("#")]),i._v(" box-sizing")]),i._v(" "),_("blockquote",[_("p",[i._v("盒模型宽度 = content + padding（左右） + border（左右） + margin（左右）。")])]),i._v(" "),_("ul",[_("li",[_("p",[i._v("box-sizing: content-box(标准盒模型，默认值)")]),i._v(" "),_("p",[i._v("标准模式下，如果我们给盒子设置的 width 和 height，实际设置的是盒模型中"),_("code",[i._v("content")]),i._v("的。（width = content）")]),i._v(" "),_("p",[i._v("在盒模型给定的width 和 height中；内边距，边框和外边距的大小决定了整个盒模型的高和宽。")]),i._v(" "),_("p",[i._v("同理，盒模型宽度 = width + padding（左右） + border（左右） + margin（左右）。")]),i._v(" "),_("p",[_("img",{attrs:{src:t(398),alt:"标准盒模型图"}})])]),i._v(" "),_("li",[_("p",[i._v("box-sizing: border-box（怪异盒模型，IE盒模型 ）")]),i._v(" "),_("p",[i._v("怪异模式下，如果我们给盒子设置的 width 和 height，实际设置的是 conent + padding + border的。（width = content + padding（左右） + border（左右））")]),i._v(" "),_("p",[i._v("在盒模型给定的width 和 height中；只有外边距的大小决定了整个盒模型的高和宽。")]),i._v(" "),_("p",[i._v("同理，盒模型宽度 = width + margin（左右）。")]),i._v(" "),_("p",[_("img",{attrs:{src:t(399),alt:"怪异盒模型图"}})])])])])}),[],!1,null,null,null);v.default=e.exports}}]);